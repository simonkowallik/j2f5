{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"j2f5 is a customization for j2cli , which again is a command line tool to template any kind of text based files using python's famous jinja2. j2f5 focuses on F5 related code (specifically iRules), but isn't limited to it. It is supposed to be a relatively lightweight addition to j2cli. Features \u00b6 adds ansible filters (when ansible is available) supports custom jinja2 delimiters sane formatting defaults by example: \u00b6 Copy and run this example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 cat <<EOF > configuration.yaml # configuration.yaml error: heading: \"Sorry :-(\" message: \"Sorry, we can't serve your request right now.\" include_id: true EOF cat <<'EOF' > lb_sorry_page.irule.j2 # lb_sorry_page.irule.j2 when LB_FAILED { {# generate unique error_id and log when error.include_id is true #} {% if error.include_id %} set error_id [lindex [AES::key 128] 2] log local0.error \"LB failed for [FLOW::this], error_id:$error_id\" {% endif %} HTTP::respond 503 content \"<html><body> <h1>{{error.heading}}</h1> <p>{{error.message}}</p> {% if error.include_id %} <p>error_id: $error_id</p> {% endif %} </body></html>\" Connection Close } EOF j2 --customize j2f5.py lb_sorry_page.irule.j2 configuration.yaml \\ -o lb_sorry_page.irule cat lb_sorry_page.irule Will produce: 1 2 3 4 5 6 7 8 9 10 # lb_sorry_page.irule.j2 when LB_FAILED { set error_id [ lindex [ AES :: key 128 ] 2 ] log local0.error \"LB failed for [FLOW::this], error_id:$error_id\" HTTP :: respond 503 content \"<html><body> <h1>Sorry :-(</h1> <p>Sorry, we can't serve your request right now.</p> <p>error_id: $error_id</p> </body></html>\" Connection Close } In configuration.yaml set: 1 include_id : false Run: 1 2 3 4 j2 --customize j2f5.py lb_sorry_page.irule.j2 configuration.yaml \\ -o lb_sorry_page.irule cat lb_sorry_page.irule And observe the result: 1 2 3 4 5 6 7 # lb_sorry_page.irule.j2 when LB_FAILED { HTTP :: respond 503 content \"<html><body> <h1>Sorry :-(</h1> <p>Sorry, we can't serve your request right now.</p> </body></html>\" Connection Close }","title":"Home"},{"location":"#features","text":"adds ansible filters (when ansible is available) supports custom jinja2 delimiters sane formatting defaults","title":"Features"},{"location":"#by-example","text":"Copy and run this example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 cat <<EOF > configuration.yaml # configuration.yaml error: heading: \"Sorry :-(\" message: \"Sorry, we can't serve your request right now.\" include_id: true EOF cat <<'EOF' > lb_sorry_page.irule.j2 # lb_sorry_page.irule.j2 when LB_FAILED { {# generate unique error_id and log when error.include_id is true #} {% if error.include_id %} set error_id [lindex [AES::key 128] 2] log local0.error \"LB failed for [FLOW::this], error_id:$error_id\" {% endif %} HTTP::respond 503 content \"<html><body> <h1>{{error.heading}}</h1> <p>{{error.message}}</p> {% if error.include_id %} <p>error_id: $error_id</p> {% endif %} </body></html>\" Connection Close } EOF j2 --customize j2f5.py lb_sorry_page.irule.j2 configuration.yaml \\ -o lb_sorry_page.irule cat lb_sorry_page.irule Will produce: 1 2 3 4 5 6 7 8 9 10 # lb_sorry_page.irule.j2 when LB_FAILED { set error_id [ lindex [ AES :: key 128 ] 2 ] log local0.error \"LB failed for [FLOW::this], error_id:$error_id\" HTTP :: respond 503 content \"<html><body> <h1>Sorry :-(</h1> <p>Sorry, we can't serve your request right now.</p> <p>error_id: $error_id</p> </body></html>\" Connection Close } In configuration.yaml set: 1 include_id : false Run: 1 2 3 4 j2 --customize j2f5.py lb_sorry_page.irule.j2 configuration.yaml \\ -o lb_sorry_page.irule cat lb_sorry_page.irule And observe the result: 1 2 3 4 5 6 7 # lb_sorry_page.irule.j2 when LB_FAILED { HTTP :: respond 503 content \"<html><body> <h1>Sorry :-(</h1> <p>Sorry, we can't serve your request right now.</p> </body></html>\" Connection Close }","title":"by example:"},{"location":"word-of-warning/","text":"A word of warning \u00b6 Excessive use of templating and 'code generation logic' in iRules (..) will make it harder to understand and debug. So choose the level of pre-processing, parameterization and use of constants wisely.","title":"A word of warning"},{"location":"word-of-warning/#a-word-of-warning","text":"Excessive use of templating and 'code generation logic' in iRules (..) will make it harder to understand and debug. So choose the level of pre-processing, parameterization and use of constants wisely.","title":"A word of warning"},{"location":"usecases/constants/","text":"Constants \u00b6 Constants? \u00b6 Wikipedia says: In computer programming, a constant is a value that cannot be altered by the program during normal execution, i.e., the value is constant. ... This is contrasted with a variable, which is an identifier with a value that can be changed during normal execution, i.e., the value is variable. Constants are useful for both programmers ... they are a form of self-documenting code. ... https://en.wikipedia.org/wiki/Constant_(computer_programming) Tcl (and therefore iRules) doesn't come with constants. Many iRule authors typically fallback to static:: variables because the name implies they are static (i.e. can't be modified). (not so) static:: \u00b6 What static:: actually means the variable is global per tmm it can be modified, but the modification only applies for the tmm it was modified from setting the same variable in different iRules typically leads to inconsistencies (\"the last set operation wins, behavior is different then expected\") it doesn't demote CMP (that's great) https://support.f5.com/csp/article/K13033#static static:: variables are often used to alter the behavior or provide configuration flags to iRules. Often this also increases the processing required to execute the iRule due to added logic. Other times it is used to make specific things configurable to an Operator who is not necessarily skilled enough to work her/his way through the entire code. Example: 1 2 3 4 5 6 7 8 when RULE_INIT { set static::syslog_severity { debug } } when HTTP_REQUEST { # ... log local0. $static::syslog_severity \"[HTTP::method] [HTTP::uri] HTTP/[HTTP::version]\" # ... } In the above iRule the syslog severity is set using a static:: variable. If the same variable name is used in another iRule, the last set operation would determine the value for all iRules using the variable. How can we use jinja2 instead? \u00b6 Create a configuration.yaml : 1 2 syslog : severity : debug Place the iRule in example.irule.j2 : 1 2 3 4 5 when HTTP_REQUEST { # ... log local0. {{ syslog.severity }} \"[HTTP::method] [HTTP::uri] HTTP/[HTTP::version]\" # ... } Using j2cli : 1 j2 example.irule.j2 configuration.yaml produces: 1 2 3 4 5 when HTTP_REQUEST { # ... log local0.debug \"[HTTP::method] [HTTP::uri] HTTP/[HTTP::version]\" # ... } Hint This actually improves performance as well, as no memory needs to be assigned for the variable nor needs to be read. Admitted, in the above example the improvement is negligible.","title":"Constants"},{"location":"usecases/constants/#constants","text":"","title":"Constants"},{"location":"usecases/constants/#constants_1","text":"Wikipedia says: In computer programming, a constant is a value that cannot be altered by the program during normal execution, i.e., the value is constant. ... This is contrasted with a variable, which is an identifier with a value that can be changed during normal execution, i.e., the value is variable. Constants are useful for both programmers ... they are a form of self-documenting code. ... https://en.wikipedia.org/wiki/Constant_(computer_programming) Tcl (and therefore iRules) doesn't come with constants. Many iRule authors typically fallback to static:: variables because the name implies they are static (i.e. can't be modified).","title":"Constants?"},{"location":"usecases/constants/#not-so-static","text":"What static:: actually means the variable is global per tmm it can be modified, but the modification only applies for the tmm it was modified from setting the same variable in different iRules typically leads to inconsistencies (\"the last set operation wins, behavior is different then expected\") it doesn't demote CMP (that's great) https://support.f5.com/csp/article/K13033#static static:: variables are often used to alter the behavior or provide configuration flags to iRules. Often this also increases the processing required to execute the iRule due to added logic. Other times it is used to make specific things configurable to an Operator who is not necessarily skilled enough to work her/his way through the entire code. Example: 1 2 3 4 5 6 7 8 when RULE_INIT { set static::syslog_severity { debug } } when HTTP_REQUEST { # ... log local0. $static::syslog_severity \"[HTTP::method] [HTTP::uri] HTTP/[HTTP::version]\" # ... } In the above iRule the syslog severity is set using a static:: variable. If the same variable name is used in another iRule, the last set operation would determine the value for all iRules using the variable.","title":"(not so) static::"},{"location":"usecases/constants/#how-can-we-use-jinja2-instead","text":"Create a configuration.yaml : 1 2 syslog : severity : debug Place the iRule in example.irule.j2 : 1 2 3 4 5 when HTTP_REQUEST { # ... log local0. {{ syslog.severity }} \"[HTTP::method] [HTTP::uri] HTTP/[HTTP::version]\" # ... } Using j2cli : 1 j2 example.irule.j2 configuration.yaml produces: 1 2 3 4 5 when HTTP_REQUEST { # ... log local0.debug \"[HTTP::method] [HTTP::uri] HTTP/[HTTP::version]\" # ... } Hint This actually improves performance as well, as no memory needs to be assigned for the variable nor needs to be read. Admitted, in the above example the improvement is negligible.","title":"How can we use jinja2 instead?"},{"location":"usecases/parameters/","text":"Parameterization \u00b6 It isn't uncommon for iRule authors to parameterize iRules. There are multiple approaches and there is no \"one fits all\" approach or \"best way to do it\". An example \u00b6 Data Groups: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ltm data-group internal blocking_hostnames { records { www.example.com { data \"\" } app.example.net { data \"\" } } type string } ltm data-group internal html_response { records { title { data \"Your request was blocked\" } message { data \"We didn't like your request, sorry.\" } } } iRule: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 when RULE_INIT { set static::dg_blocking_name { blocking_hostnames } set static::dg_response_text { html_response } } when HTTP_REQUEST { set host_name [ string tolower [ HTTP :: header value { Host }]] if { [ class match -- $host_name equals $static::dg_blocking_name ] } { HTTP :: respond 403 content \" <html> <head>[class lookup {title} $static::dg_response_text]</head> <body>[class lookup {message} $static::dg_response_text]</body> </html> \" Content-Type { text / html } Connection { Close } TCP :: close } } Complaints? \u00b6 Yes, some. The data-group blocking_hostnames stores FQDNs (as keys), the iRule looks up the HTTP host header against it to determine if a HTTP response should be generated. The HTML response is also defined in a data-group. In this case it doesn't seem likely this is re-used anywhere else nor extended as the keys are hard-coded in the iRule. The iRule uses static:: variables to reference the data-group names. On the first look this allows re-use of the iRule by modifying the values of the static:: variables, but that's not the case. See Constants . Rule of thumb In general separating data (data-groups) and configuration (constants, data-groups) from the code (iRules) is a good approach. It breaks up complexity, supports automation and configuration by non-iRule-savvy Operators and allows for better re-use of code. Use data-groups when: (a lot) of entries are required data-group is re-used in multiple areas data changes often data should be changeable via an API (independently from the code) the data is too big for an iRule (might indicate that the data-group isn't perfectly suited either -> iFile?) a non iRule-savvy Operator should change the data Jinja2 \u00b6 variant 1 \u00b6 Data Groups untouched. iRule ( irule.j2 ): 1 2 3 4 5 6 7 8 9 10 11 12 when HTTP_REQUEST { set host_name [ string tolower [ HTTP :: header value { Host }]] if { [ class match -- $host_name equals {{ data_group.blocking_name }}] } { HTTP :: respond 403 content \" <html> <head>[class lookup {title} {{data_group.response_text}}]</head> <body>[class lookup {message} {{data_group.response_text}}]</body> </html> \" Content-Type { text / html } Connection { Close } TCP :: close } } configuration.yaml : 1 2 3 data_group : blocking_name : blocking_hostnames response_text : html_response 1 j2 irule.j2 configuration.yaml produces: 1 2 3 4 5 6 7 8 9 10 11 12 when HTTP_REQUEST { set host_name [ string tolower [ HTTP :: header value { Host }]] if { [ class match -- $host_name equals blocking_hostnames ] } { HTTP :: respond 403 content \" <html> <head>[class lookup {title} response_text]</head> <body>[class lookup {message} response_text]</body> </html> \" Content-Type { text / html } Connection { Close } TCP :: close } } variant 2 \u00b6 Data Groups: ltm data-group internal html_response removed. iRule ( irule.j2 ): 1 2 3 4 5 6 7 8 9 10 11 12 when HTTP_REQUEST { set host_name [ string tolower [ HTTP :: header value { Host }]] if { [ class match -- $host_name equals {{ data_group.blocking_name }}] } { HTTP :: respond 403 content \" <html> <head>{{response_text.title}}</head> <body>{{response_text.message}}</body> </html> \" Content-Type { text / html } Connection { Close } TCP :: close } } configuration.yaml : 1 2 3 4 5 data_group : blocking_name : blocking_hostnames response_text : title : \"Your request was blocked\" message : \"We didn't like your request, sorry.\" running j2cli : 1 j2 irule.j2 configuration.yaml produces: 1 2 3 4 5 6 7 8 9 10 11 12 when HTTP_REQUEST { set host_name [ string tolower [ HTTP :: header value { Host }]] if { [ class match -- $host_name equals blocking_hostnames ] } { HTTP :: respond 403 content \" <html> <head>Your request was blocked</head> <body>We didn't like your request, sorry.</body> </html> \" Content-Type { text / html } Connection { Close } TCP :: close } } Improvement: Down from three to one data group lookup operation!","title":"Parameterization"},{"location":"usecases/parameters/#parameterization","text":"It isn't uncommon for iRule authors to parameterize iRules. There are multiple approaches and there is no \"one fits all\" approach or \"best way to do it\".","title":"Parameterization"},{"location":"usecases/parameters/#an-example","text":"Data Groups: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ltm data-group internal blocking_hostnames { records { www.example.com { data \"\" } app.example.net { data \"\" } } type string } ltm data-group internal html_response { records { title { data \"Your request was blocked\" } message { data \"We didn't like your request, sorry.\" } } } iRule: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 when RULE_INIT { set static::dg_blocking_name { blocking_hostnames } set static::dg_response_text { html_response } } when HTTP_REQUEST { set host_name [ string tolower [ HTTP :: header value { Host }]] if { [ class match -- $host_name equals $static::dg_blocking_name ] } { HTTP :: respond 403 content \" <html> <head>[class lookup {title} $static::dg_response_text]</head> <body>[class lookup {message} $static::dg_response_text]</body> </html> \" Content-Type { text / html } Connection { Close } TCP :: close } }","title":"An example"},{"location":"usecases/parameters/#complaints","text":"Yes, some. The data-group blocking_hostnames stores FQDNs (as keys), the iRule looks up the HTTP host header against it to determine if a HTTP response should be generated. The HTML response is also defined in a data-group. In this case it doesn't seem likely this is re-used anywhere else nor extended as the keys are hard-coded in the iRule. The iRule uses static:: variables to reference the data-group names. On the first look this allows re-use of the iRule by modifying the values of the static:: variables, but that's not the case. See Constants . Rule of thumb In general separating data (data-groups) and configuration (constants, data-groups) from the code (iRules) is a good approach. It breaks up complexity, supports automation and configuration by non-iRule-savvy Operators and allows for better re-use of code. Use data-groups when: (a lot) of entries are required data-group is re-used in multiple areas data changes often data should be changeable via an API (independently from the code) the data is too big for an iRule (might indicate that the data-group isn't perfectly suited either -> iFile?) a non iRule-savvy Operator should change the data","title":"Complaints?"},{"location":"usecases/parameters/#jinja2","text":"","title":"Jinja2"},{"location":"usecases/parameters/#variant-1","text":"Data Groups untouched. iRule ( irule.j2 ): 1 2 3 4 5 6 7 8 9 10 11 12 when HTTP_REQUEST { set host_name [ string tolower [ HTTP :: header value { Host }]] if { [ class match -- $host_name equals {{ data_group.blocking_name }}] } { HTTP :: respond 403 content \" <html> <head>[class lookup {title} {{data_group.response_text}}]</head> <body>[class lookup {message} {{data_group.response_text}}]</body> </html> \" Content-Type { text / html } Connection { Close } TCP :: close } } configuration.yaml : 1 2 3 data_group : blocking_name : blocking_hostnames response_text : html_response 1 j2 irule.j2 configuration.yaml produces: 1 2 3 4 5 6 7 8 9 10 11 12 when HTTP_REQUEST { set host_name [ string tolower [ HTTP :: header value { Host }]] if { [ class match -- $host_name equals blocking_hostnames ] } { HTTP :: respond 403 content \" <html> <head>[class lookup {title} response_text]</head> <body>[class lookup {message} response_text]</body> </html> \" Content-Type { text / html } Connection { Close } TCP :: close } }","title":"variant 1"},{"location":"usecases/parameters/#variant-2","text":"Data Groups: ltm data-group internal html_response removed. iRule ( irule.j2 ): 1 2 3 4 5 6 7 8 9 10 11 12 when HTTP_REQUEST { set host_name [ string tolower [ HTTP :: header value { Host }]] if { [ class match -- $host_name equals {{ data_group.blocking_name }}] } { HTTP :: respond 403 content \" <html> <head>{{response_text.title}}</head> <body>{{response_text.message}}</body> </html> \" Content-Type { text / html } Connection { Close } TCP :: close } } configuration.yaml : 1 2 3 4 5 data_group : blocking_name : blocking_hostnames response_text : title : \"Your request was blocked\" message : \"We didn't like your request, sorry.\" running j2cli : 1 j2 irule.j2 configuration.yaml produces: 1 2 3 4 5 6 7 8 9 10 11 12 when HTTP_REQUEST { set host_name [ string tolower [ HTTP :: header value { Host }]] if { [ class match -- $host_name equals blocking_hostnames ] } { HTTP :: respond 403 content \" <html> <head>Your request was blocked</head> <body>We didn't like your request, sorry.</body> </html> \" Content-Type { text / html } Connection { Close } TCP :: close } } Improvement: Down from three to one data group lookup operation!","title":"variant 2"},{"location":"usecases/preprocess/","text":"Preprocess(or) \u00b6 Wikipedia says: In computer science, a preprocessor is a program that processes its input data to produce output that is used as input to another program. The output is said to be a preprocessed form of the input data, which is often used by some subsequent programs like compilers. https://en.wikipedia.org/wiki/Preprocessor Preprocessing for iRules is helpful to eliminate unnecessary code paths or enable specific features. Example: Debug logging \u00b6 One of the most common use-cases in iRules for constants is to enable conditional debug logging. Example: 1 2 3 4 5 6 7 8 9 10 when RULE_INIT { set static::debug 1 } when HTTP_REQUEST { # ... if { $static::debug } { log local0.debug \"[HTTP::method] [HTTP::uri] HTTP/[HTTP::version]\" } # ... } This is not only bad for the reasons outlined in constants but also from an iRule processing (and performance) standpoint. the if {$static::debug} expression is evaluated whenever the HTTP_REQUEST event is fired. Using jinja2 we can introduce a condition and preprocess the iRule, so that the log statement is only included when debugging is actually enabled. Create a configuration.yaml : 1 debug : 1 Place the iRule in example.irule.j2 : 1 2 3 4 5 6 7 when HTTP_REQUEST { # ... { % if debug % } log local0.debug \"[HTTP::method] [HTTP::uri] HTTP/[HTTP::version]\" { % endif % } # ... } If debug is indeed 1 , it would produce the following iRule: 1 2 3 4 5 when HTTP_REQUEST { # ... log local0.debug \"[HTTP::method] [HTTP::uri] HTTP/[HTTP::version]\" # ... } If debug is 0 , the iRule would not contain the log statement at all.","title":"Preprocess(or)"},{"location":"usecases/preprocess/#preprocessor","text":"Wikipedia says: In computer science, a preprocessor is a program that processes its input data to produce output that is used as input to another program. The output is said to be a preprocessed form of the input data, which is often used by some subsequent programs like compilers. https://en.wikipedia.org/wiki/Preprocessor Preprocessing for iRules is helpful to eliminate unnecessary code paths or enable specific features.","title":"Preprocess(or)"},{"location":"usecases/preprocess/#example-debug-logging","text":"One of the most common use-cases in iRules for constants is to enable conditional debug logging. Example: 1 2 3 4 5 6 7 8 9 10 when RULE_INIT { set static::debug 1 } when HTTP_REQUEST { # ... if { $static::debug } { log local0.debug \"[HTTP::method] [HTTP::uri] HTTP/[HTTP::version]\" } # ... } This is not only bad for the reasons outlined in constants but also from an iRule processing (and performance) standpoint. the if {$static::debug} expression is evaluated whenever the HTTP_REQUEST event is fired. Using jinja2 we can introduce a condition and preprocess the iRule, so that the log statement is only included when debugging is actually enabled. Create a configuration.yaml : 1 debug : 1 Place the iRule in example.irule.j2 : 1 2 3 4 5 6 7 when HTTP_REQUEST { # ... { % if debug % } log local0.debug \"[HTTP::method] [HTTP::uri] HTTP/[HTTP::version]\" { % endif % } # ... } If debug is indeed 1 , it would produce the following iRule: 1 2 3 4 5 when HTTP_REQUEST { # ... log local0.debug \"[HTTP::method] [HTTP::uri] HTTP/[HTTP::version]\" # ... } If debug is 0 , the iRule would not contain the log statement at all.","title":"Example: Debug logging"},{"location":"why-j2f5/custom_delimiters/","text":"j2f5 allows you to easily change the jinja2 delimiters. For example by including the below in your configuration (YAML in this example), the delimiters will change to something more similar to the iApp macro engine. 1 2 3 4 5 6 7 templating_settings : block_start_string : '<%' block_end_string : '%>' variable_start_string : '<%=' variable_end_string : '%>' comment_start_string : '<#' comment_end_string : '#>' Example iRule template: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # lb_sorry_page.irule.j2 when LB_FAILED { < # generate unique error_id and log when error.include_id is true #> <% if error.include_id %> set error_id [ lindex [ AES :: key 128 ] 2 ] log local0.error \"LB failed for [FLOW::this], error_id:$error_id\" <% endif %> HTTP :: respond 503 content \"<html><body> <h1><%=error.heading%></h1> <p><%=error.message%></p> <% if error.include_id %> <p>error_id: $error_id</p> <% endif %> </body></html>\" Connection Close } Info This can be helpful when { } curly braces have been used for other purposes or produce issues due to TCL \"overlaps\" or different uses.","title":"Custom delimiters"},{"location":"why-j2f5/usage/","text":"j2f5 uses the hooks exposed by j2cli to alter behavior. There are two ways to use j2f5 : 1: --customize \u00b6 1 j2 --customize ./j2f5.py <template> <configuration> This is the default option provided by j2cli. 2: directly \u00b6 1 python3 ./j2f5.py <template> <configuration> j2f5 wraps the j2cli command line and injects itself using --customize for ease of use. Info In both cases j2cli must be installed. To install, run: 1 pip3 install j2cli","title":"Usage"},{"location":"why-j2f5/usage/#1-customize","text":"1 j2 --customize ./j2f5.py <template> <configuration> This is the default option provided by j2cli.","title":"1: --customize"},{"location":"why-j2f5/usage/#2-directly","text":"1 python3 ./j2f5.py <template> <configuration> j2f5 wraps the j2cli command line and injects itself using --customize for ease of use. Info In both cases j2cli must be installed. To install, run: 1 pip3 install j2cli","title":"2: directly"}]}